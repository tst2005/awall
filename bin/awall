#!/usr/bin/lua

do local sources, priorities = {}, {};assert(not sources["awall.uerror"])sources["awall.uerror"]=([===[-- <pack awall.uerror> --
--[[
User error handling for Alpine Wall
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--


local M = {}

local prefix = 'awall user error: '

function M.raise(msg) error(prefix..msg) end

function M.call(f, ...)
   local arg = {...}
   return xpcall(
      function() f(table.unpack(arg)) end,
      function(msg)
	 local si, ei = msg:find(prefix, 1, true)
	 if si then msg = 'awall: '..msg:sub(ei + 1, -1) end
   	 io.stderr:write(msg..'\n')
   	 if not si then io.stderr:write(debug.traceback()..'\n') end
      end
   )
end

return M
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall.class"])sources["awall.class"]=([===[-- <pack awall.class> --
--[[
Class model with inheritance and morphing support for Alpine Wall
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--

local Object

local function class(base)
   local cls = {}

   function cls.super(obj)
      return setmetatable(
	 {},
	 {
	    __index=function(t, k)
	       local v = base[k]
	       if type(v) ~= 'function' then return v end
	       return function(...)
		  local arg = {...}
		  arg[1] = obj
		  return v(table.unpack(arg))
	       end
	    end
	 }
      )
   end

   function cls:morph(...)
      setmetatable(self, {__index = cls})
      self:init(...)
      return self
   end

   local mt = {__call=function(self, ...) return cls.morph({}, ...) end}

   if not base and Object then base = Object end
   if base then mt.__index = base end

   return setmetatable(cls, mt)
end

Object = class()
function Object:init(...) end

return class
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall.policy"])sources["awall.policy"]=([===[-- <pack awall.policy> --
--[[
Policy file handling for Alpine Wall
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--


local resolve = require('awall.dependency')
local class = require('awall.class')
local raise = require('awall.uerror').raise

local util = require('awall.util')
local contains = util.contains
local keys = util.keys
local listpairs = util.listpairs
local map = util.map


local json = require('cjson')
local posix = require('posix')


local PolicyConfig = class()

function PolicyConfig:init(data, source, policies)
   self.data = data
   self.source = source
   self.policies = policies
end

function PolicyConfig:expand()

   local function expand(value)
      if type(value) == 'table' then return map(value, expand) end

      local visited = {}
      local pattern = '%$(%a[%w_]*)'
      
      while type(value) == 'string' do
	 local si, ei, name = value:find(pattern)
	 if not si then break end
	 
	 if contains(visited, name) then
	    raise('Circular variable definition: '..name)
	 end
	 table.insert(visited, name)
	 
	 local var = self.data.variable[name]
	 if var == nil then raise('Invalid variable reference: '..name) end
	 
	 if si == 1 and ei == value:len() then value = var
	 elseif contains({'number', 'string'}, type(var)) then
	    value = value:sub(1, si - 1)..var..value:sub(ei + 1, -1)
	 else
	    raise('Attempted to concatenate complex variable: '..name)
	 end
      end

      if value == '' then return end
      return value
   end

   return expand(self.data)
end


local Policy = class()

function Policy:init() self.enabled = self.type == 'mandatory' end

function Policy:load()
   local file = io.open(self.path)
   if not file then raise('Unable to read policy file '..self.path) end
   local data = file:read('*all')
   file:close()

   local success, res = pcall(json.decode, data)
   if success then return res end
   raise(res..' while parsing '..self.path)
end

function Policy:checkoptional()
   if self.type ~= 'optional' then raise('Not an optional policy: '..name) end
end

function Policy:enable()
   self:checkoptional()
   if self.enabled then raise('Policy already enabled: '..self.name) end   
   assert(posix.link(self.path, self.confdir..'/'..self.fname, true))
end

function Policy:disable()
   self:checkoptional()
   if not self.enabled then raise('Policy already disabled: '..self.name) end
   assert(os.remove(self.confdir..'/'..self.fname))
end


local defdirs = {
   mandatory={'/etc/awall', '/usr/share/awall/mandatory'},
   optional={'/etc/awall/optional', '/usr/share/awall/optional'},
   private={'/etc/awall/private', '/usr/share/awall/private'}
}

local PolicySet = class()

function PolicySet:init(dirs)
   local confdir = (dirs.mandatory or defdirs.mandatory)[1]
   self.policies = {}

   for i, cls in ipairs{'private', 'optional', 'mandatory'} do
      for i, dir in ipairs(dirs[cls] or defdirs[cls]) do
	 for _, fname in ipairs(posix.dir(dir)) do
	    local si, ei, name = fname:find('^([%w-]+)%.json$')
	    if name then
	       local pol = self.policies[name]

	       local path = dir..'/'..fname
	       if path:sub(1, 1) ~= '/' then
		  path = posix.getcwd()..'/'..path
	       end

	       local loc = posix.realpath(path)

	       if pol then
		  if pol.loc ~= loc then
		     raise('Duplicate policy name: '..name)
		  end

		  if dir == confdir and pol.type == 'optional' then
		     pol.enabled = true
		  else pol.type = cls end

	       else
		  self.policies[name] = Policy.morph{
		     name=name,
		     type=cls,
		     path=path,
		     fname=fname,
		     loc=loc,
		     confdir=confdir
		  }
	       end
	    end
	 end
      end
   end
end


function PolicySet:load()

   local imported = {['%defaults']={}}
   
   local function require(policy)
      if imported[policy.name] then return end

      local data = policy:load()
      imported[policy.name] = data

      if not data.after then
	 data.after = {}
	 for _, name in listpairs(data.import) do
	    if not contains(data.before, name) then
	       table.insert(data.after, name)
	    end
	 end
      end

      if not contains(data.before, '%defaults') then
	 data.after = util.list(data.after)
	 table.insert(data.after, '%defaults')
      end

      for i, name in listpairs(data.import) do
	 if name:sub(1, 1) ~= '%' then
	    local pol = self.policies[name]
	    if not pol then
	       raise('Invalid policy reference from '..policy.name..': '..name)
	    end
	    require(pol)
	 end
      end
   end

   for name, policy in pairs(self.policies) do
      if policy.enabled then require(policy) end
   end


   local order = resolve(imported)
   if type(order) ~= 'table' then
      raise('Circular ordering directives: '..order)
   end


   local input = {}
   local source = {}

   for i, name in ipairs(order) do
      for cls, objs in pairs(imported[name]) do
	 if not contains(
	    {'description', 'import', 'after', 'before'},
	    cls
	 ) then
	    if type(objs) ~= 'table' then
	       raise('Invalid top-level attribute: '..cls..' ('..name..')')
	    end

	    util.setdefault(source, cls, {})

	    if not input[cls] then
	       input[cls] = objs
	       for k, v in pairs(objs) do source[cls][k] = name end

	    else
	       local fk = next(input[cls])
	       map(
		  keys(objs),
		  function(k)
		     if type(k) ~= type(fk) then
			raise(
			   'Type mismatch in '..cls..' definitions ('..
			      name..', '..source[cls][fk]..')'
			)
		     end
		  end
	       )

	       if objs[1] then
		  local last = #input[cls]
		  util.extend(input[cls], objs)
		  for i = 1,#objs do source[cls][last + i] = name end

	       else
		  for k, v in pairs(objs) do
		     input[cls][k] = v
		     source[cls][k] = name
		  end
	       end
	    end
	 end
      end
   end

   return PolicyConfig(input, source, keys(imported))
end

return PolicySet
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall.optfrag"])sources["awall.optfrag"]=([===[-- <pack awall.optfrag> --
--[[
Option fragment module for Alpine Wall
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--


local M = {}

function M.combinations(of1, ...)
   local arg = {...}

   if #arg == 0 then return of1 end

   if not of1 then return M.combinations(...) end

   local of2 = arg[1]
   table.remove(arg, 1)
   if not of2 then return M.combinations(of1, table.unpack(arg)) end

   local res = {}
   for i, x in ipairs(of1) do
      for i, y in ipairs(of2) do

	 local of = {}
	 for k, v in pairs(x) do
	    if k ~= 'opts' then of[k] = v end
	 end

	 local match = true
	 for k, v in pairs(y) do
	    if k ~= 'opts' then
	       if of[k] and v ~= of[k] then
		  match = false
		  break
	       end
	       of[k] = v
	    end
	 end

	 if match then
	    if x.opts then
	       if y.opts then of.opts = x.opts..' '..y.opts
	       else of.opts = x.opts end
	    else of.opts = y.opts end
	    table.insert(res, of)
	 end
      end
   end

   return M.combinations(res, table.unpack(arg))
end

function M.location(of) return of.family..'/'..of.table..'/'..of.chain end

function M.command(of)
   return (of.opts and of.opts..' ' or '')..
      (of.target and '-j '..of.target or '')
end

return M
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall.model"])sources["awall.model"]=([===[-- <pack awall.model> --
--[[
Base data model for Alpine Wall
Copyright (C) 2012-2015 Kaarle Ritvanen
See LICENSE file for license details
]]--


local M = {}


local loadclass = require('awall').loadclass
M.class = require('awall.class')
local resolve = require('awall.host')
local builtin = require('awall.iptables').builtin

local optfrag = require('awall.optfrag')
local combinations = optfrag.combinations

local raise = require('awall.uerror').raise

local util = require('awall.util')
local contains = util.contains
local extend = util.extend
local filter = util.filter
local join = util.join
local listpairs = util.listpairs
local maplist = util.maplist
local setdefault = util.setdefault


local startswith = require('stringy').startswith


M.ConfigObject = M.class()

function M.ConfigObject:init(context, location)
   if context then
      self.context = context
      self.root = context.objects
   end
   self.location = location

   self.extraobjs = {}
   self.uniqueids = {}
end

function M.ConfigObject:create(cls, params, label, index)
   local key
   if label then
      key = label..(index or '')
      local obj = self.extraobjs[key]
      if obj then return obj end
   end

   if type(cls) == 'string' then
      local name = cls
      cls = loadclass(cls)
      if not cls then
	 self:error('Support for '..name..' objects not installed')
      end
   end

   if type(params) ~= 'table' then params = {params} end
   params.label = join(self.label, '-', label)

   local obj = cls.morph(params, self.context, self.location)
   if key then self.extraobjs[key] = obj end
   return obj
end

function M.ConfigObject:uniqueid(key)
   if not key then key = '' end
   if self.uniqueids[key] then return self.uniqueids[key] end

   local lastid = setdefault(self.context, 'lastid', {})
   local res = join(key, '-', self.label)
   lastid[res] = setdefault(lastid, res, -1) + 1
   res = res..'-'..lastid[res]

   self.uniqueids[key] = res
   return res
end

function M.ConfigObject:error(msg) raise(self.location..': '..msg) end

function M.ConfigObject:warning(msg)
   io.stderr:write(self.location..': '..msg..'\n')
end

function M.ConfigObject:trules() return {} end

function M.ConfigObject:info()
   local res = {}
   for i, trule in ipairs(self:trules()) do
      table.insert(res, {'  '..optfrag.location(trule), optfrag.command(trule)})
   end
   return res
end


M.Zone = M.class(M.ConfigObject)

function M.Zone:optfrags(dir)
   local iopt, aopt, iprop, aprop
   if dir == 'in' then
      iopt, aopt, iprop, aprop = 'i', 's', 'in', 'src'
   elseif dir == 'out' then
      iopt, aopt, iprop, aprop = 'o', 'd', 'out', 'dest'
   else assert(false) end

   local aopts = nil
   if self.addr then
      aopts = {}
      for i, hostdef in listpairs(self.addr) do
	 for i, addr in ipairs(resolve(hostdef, self)) do
	    table.insert(aopts,
			 {family=addr[1],
			  [aprop]=addr[2],
			  opts='-'..aopt..' '..addr[2]})
	 end
      end
   end

   return combinations(
      maplist(
	 self.iface,
	 function(x) return {[iprop]=x, opts='-'..iopt..' '..x} end
      ),
      aopts
   )
end


M.fwzone = M.Zone()


local IPSet = M.class(M.ConfigObject)

function IPSet:init(...)
   IPSet.super(self):init(...)

   if not self.type then self:error('Type not defined') end

   if startswith(self.type, 'bitmap:') then
      if not self.range then self:error('Range not defined') end
      self.options = {self.type, 'range', self.range}
      self.family = 'inet'

   elseif startswith(self.type, 'hash:') then
      if not self.family then self:error('Family not defined') end
      self.options = {self.type, 'family', self.family}

   elseif self.type == 'list:set' then self.options = {self.type}

   else self:error('Invalid type: '..self.type) end
end


M.Rule = M.class(M.ConfigObject)


function M.Rule:init(...)
   M.Rule.super(self):init(...)

   for i, prop in ipairs({'in', 'out'}) do
      self[prop] = self[prop] and maplist(
	 self[prop],
	 function(z)
	    if type(z) ~= 'string' then return z end
	    return z == '_fw' and M.fwzone or
	       self.root.zone[z] or
	       self:error('Invalid zone: '..z)
	 end
      )
   end

   if self.service then
      if not self.label and type(self.service) == 'string' then
	 self.label = self.service
      end

      self.service = util.list(self.service)

      for i, serv in ipairs(self.service) do
	 if type(serv) == 'string' then
	    self.service[i] = self.root.service[serv] or
	       self:error('Invalid service: '..serv)
	 end
	 for i, sdef in listpairs(self.service[i]) do
	    if not sdef.proto then self:error('Protocol not defined') end
	    sdef.proto = (
	       {[1]='icmp', [6]='tcp', [17]='udp', [58]='ipv6-icmp'}
            )[sdef.proto] or sdef.proto
	 end
      end
   end
end


function M.Rule:direction(dir)
   if dir == 'in' then return self.reverse and 'out' or 'in' end
   if dir == 'out' then return self.reverse and 'in' or 'out' end
   self:error('Invalid direction: '..dir)
end


function M.Rule:zoneoptfrags()

   local function zonepair(zin, zout)

      local function zofs(zone, dir)
	 if not zone then return zone end
	 return zone:optfrags(dir)
      end

      local chain, ofrags

      if zin == M.fwzone or zout == M.fwzone then
	 if zin == zout then return {} end
	 local dir, z = 'in', zin
	 if zin == M.fwzone then dir, z = 'out', zout end
	 chain = dir:upper()..'PUT'
	 ofrags = zofs(z, dir)

      elseif not zin or not zout then

	 if zin then
	    chain = 'PREROUTING'
	    ofrags = zofs(zin, 'in')

	 elseif zout then
	    chain = 'POSTROUTING'
	    ofrags = zofs(zout, 'out')
	 end

      else
	 chain = 'FORWARD'
	 ofrags = combinations(zofs(zin, 'in'), zofs(zout, 'out'))

	 if ofrags and not zout['route-back'] then
	    ofrags = filter(
	       ofrags,
	       function(of)
		  return not (of['in'] and of.out and of['in'] == of.out)
	       end
	    )
	 end
      end

      return combinations(ofrags,
			  chain and {{chain=chain}} or {{chain='PREROUTING'},
							{chain='OUTPUT'}})
   end

   local res = {}
   local izones = self[self:direction('in')] or {}
   local ozones = self[self:direction('out')] or {}

   for i = 1,math.max(1, table.maxn(izones)) do
      for j = 1,math.max(1, table.maxn(ozones)) do
	 extend(res, zonepair(izones[i], ozones[j]))
      end
   end

   return res
end


function M.Rule:servoptfrags()

   if not self.service then return end

   local fports = {inet={}, inet6={}}
   local res = {}

   for i, serv in ipairs(self.service) do
      for i, sdef in listpairs(serv) do
	 if contains({'tcp', 'udp'}, sdef.proto) then
	    for family, ports in pairs(fports) do
	       if not sdef.family or family == sdef.family then

		  local new = not ports[sdef.proto]
		  if new then ports[sdef.proto] = {} end

		  if new or ports[sdef.proto][1] then
		     if sdef.port then
			extend(
			   ports[sdef.proto],
			   maplist(
			      sdef.port,
			      function(p) return tostring(p):gsub('-', ':') end
			   )
			)
		     else ports[sdef.proto] = {} end
		  end
	       end
	    end

	 else

	    local opts = '-p '..sdef.proto
	    local family = nil

	    -- TODO multiple ICMP types per rule
	    local oname
	    if sdef.proto == 'icmp' then
	       family = 'inet'
	       oname = 'icmp-type'
	    elseif contains({'ipv6-icmp', 'icmpv6'}, sdef.proto) then
	       family = 'inet6'
	       oname = 'icmpv6-type'
	    elseif sdef.type or sdef['reply-type'] then
	       self:error('Type specification not valid with '..sdef.proto)
	    end

	    if sdef.family then
	       if not family then family = sdef.family
	       elseif family ~= sdef.family then
		  self:error(
		     'Protocol '..sdef.proto..' is incompatible with '..sdef.family
		  )
	       end
	    end

	    if sdef.type then
	       opts = opts..' --'..oname..' '..(
		  self.reverse and sdef['reply-type'] or sdef.type
	       )
	    end
	    table.insert(res, {family=family, opts=opts})
	 end
      end
   end

   local popt = ' --'..(self.reverse and 's' or 'd')..'port'
   for family, pports in pairs(fports) do
      local ofrags = {}

      for proto, ports in pairs(pports) do
	 local propt = '-p '..proto

	 if ports[1] then
	    local len = #ports
	    repeat
	       local opts

	       if len == 1 then
		  opts = propt..popt..' '..ports[1]
		  len = 0

	       else
		  opts = propt..' -m multiport'..popt..'s '
		  local pc = 0
		  repeat
		     local sep = pc == 0 and '' or ','
		     local port = ports[1]
		     
		     pc = pc + (port:find(':') and 2 or 1)
		     if pc > 15 then break end
		     
		     opts = opts..sep..port
		     
		     table.remove(ports, 1)
		     len = len - 1
		  until len == 0
	       end

	       table.insert(ofrags, {opts=opts})
	    until len == 0

	 else table.insert(ofrags, {opts=propt}) end
      end

      extend(res, combinations(ofrags, {{family=family}}))
   end

   return res
end

function M.Rule:destoptfrags()
   return self:create(M.Zone, {addr=self.dest}):optfrags(self:direction('out'))
end

function M.Rule:table() return 'filter' end

function M.Rule:position() return 'append' end

function M.Rule:target()
   -- alpine v2.7 compatibility
   if self.action == 'accept' then
      self:warning("'accept' action deprecated in favor of 'exclude'")
      self.action = 'exclude'
   end

   if self.action == 'exclude' then return 'ACCEPT' end
   if self.action and self.action ~= 'include' then
      self:error('Invalid action: '..self.action)
   end
end


function M.Rule:trules()

   local function tag(ofrags, tag, value)
      for i, ofrag in ipairs(ofrags) do
	 assert(not ofrag[tag])
	 ofrag[tag] = value
      end
   end

   local families

   local function setfamilies(ofrags)
      if ofrags then
	 families = {}
	 for i, ofrag in ipairs(ofrags) do
	    if not ofrag.family then
	       families = nil
	       return
	    end
	    table.insert(families, ofrag.family)
	 end
      else families = nil end
   end

   local function ffilter(ofrags)
      if not ofrags or not ofrags[1] or not families then return ofrags end
      return filter(
	 ofrags,
	 function(of)
	    return not of.family or contains(families, of.family)
	 end
      )
   end

   local res = self:zoneoptfrags()

   if self.ipset then
      local ipsetofrags = {}
      for i, ipset in listpairs(self.ipset) do
	 if not ipset.name then self:error('Set name not defined') end

	 local setdef = self.root.ipset and self.root.ipset[ipset.name]
	 if not setdef then self:error('Invalid set name') end

	 if not ipset.args then
	    self:error('Set direction arguments not defined')
	 end

	 local setopts = '-m set --match-set '..ipset.name..' '
	 setopts = setopts..table.concat(util.map(util.list(ipset.args),
						  function(a)
						     if self:direction(a) == 'in' then
							return 'src'
						     end
						     return 'dst'
						  end),
					 ',')
	 table.insert(ipsetofrags, {family=setdef.family, opts=setopts})
      end
      res = combinations(res, ipsetofrags)
   end

   if self.ipsec then
      res = combinations(res,
			 {{opts='-m policy --pol ipsec --dir '..self:direction(self.ipsec)}})
   end

   res = combinations(res, self:servoptfrags())

   setfamilies(res)

   local addrofrags = combinations(
      self:create(M.Zone, {addr=self.src}):optfrags(self:direction('in')),
      self:destoptfrags()
   )
   local combined = res

   if addrofrags then
      addrofrags = ffilter(addrofrags)
      setfamilies(addrofrags)
      res = ffilter(res)

      combined = {}
      for i, ofrag in ipairs(res) do
	 local aofs = combinations(addrofrags, {{family=ofrag.family}})
	 local cc = combinations({ofrag}, aofs)
	 if #cc < #aofs then
	    combined = nil
	    break
	 end
	 extend(combined, cc)
      end
   end

   local target
   if combined then
      target = self:target()
      res = combined
   else target = self:uniqueid('address') end

   tag(res, 'position', self:position())

   res = combinations(res, {{target=target}})

   if not combined then
      extend(
	 res,
	 combinations(addrofrags, {{chain=target, target=self:target()}})
      )
   end

   extend(res, self:extraoptfrags())

   local tbl = self:table()

   local function convertchains(ofrags)
      local res = {}

      for i, ofrag in ipairs(ofrags) do

	 if contains(builtin[tbl], ofrag.chain) then table.insert(res, ofrag)
	 else
	    local ofs, recursive
	    if ofrag.chain == 'PREROUTING' then
	       ofs = {{chain='FORWARD'}, {chain='INPUT'}}
	    elseif ofrag.chain == 'POSTROUTING' then
	       ofs = {{chain='FORWARD'}, {chain='OUTPUT'}}
	       recursive = true
	    elseif ofrag.chain == 'INPUT' then
	       ofs = {{opts='-m addrtype --dst-type LOCAL', chain='PREROUTING'}}
	    elseif ofrag.chain == 'FORWARD' then
	       ofs = {
		  {opts='-m addrtype ! --dst-type LOCAL', chain='PREROUTING'}
	       }
	    end

	    if ofs then
	       ofrag.chain = nil
	       ofs = combinations(ofs, {ofrag})
	       if recursive then ofs = convertchains(ofs) end
	       extend(res, ofs)

	    else table.insert(res, ofrag) end
	 end
      end

      return res
   end

   res = convertchains(ffilter(res))
   tag(res, 'table', tbl, false)

   local function checkzof(ofrag, dir, chains)
      if ofrag[dir] and contains(chains, ofrag.chain) then
	 self:error('Cannot specify '..dir..'bound interface ('..ofrag[dir]..')')
      end
   end

   for i, ofrag in ipairs(res) do
      checkzof(ofrag, 'in', {'OUTPUT', 'POSTROUTING'})
      checkzof(ofrag, 'out', {'INPUT', 'PREROUTING'})
   end
   
   return combinations(res, ffilter({{family='inet'}, {family='inet6'}}))
end

function M.Rule:extraoptfrags() return {} end


M.Limit = M.class(M.ConfigObject)

function M.Limit:init(...)
   M.Limit.super(self):init(...)

   if not self.count then
      if not self[1] then
	 self:error('Packet count not defined for limit')
      end
      self.count = self[1]
   end

   setdefault(self, 'interval', 1)

   if type(setdefault(self, 'mask', {})) == 'number' then
      self.mask = {src=self.mask}
   end
   for _, family in ipairs{'inet', 'inet6'} do
      setdefault(self.mask, family, util.copy(self.mask))
      for _, attr in ipairs{'src', 'dest'} do
	 local mask = setdefault(
	    self.mask[family],
	    attr,
	    ({src=({inet=32, inet6=128})[family], dest=0})[attr]
	 )
	 if mask > 0 then
	    self.mask[family].mode =
	       self.mask[family].mode and true or {attr, mask}
	 end
      end
   end
end

function M.Limit:rate() return self.count / self.interval end

function M.Limit:intrate() return math.ceil(self:rate()) end

function M.Limit:limitofrags(name)
   local rate = self:rate()
   local unit
   for _, quantum in ipairs{
      {1, 'second'}, {60, 'minute'}, {60, 'hour'}, {24, 'day'}
   } do
      rate = rate * quantum[1]
      unit = quantum[2]
      if rate >= 1 then break end
   end
   rate = math.ceil(rate)..'/'..unit

   local ofrags = {}

   for _, family in ipairs{'inet', 'inet6'} do
      local keys = {}
      local maskopts = ''
      for _, attr in ipairs{'src', 'dest'} do
	 local mask = self.mask[family][attr]
	 if mask > 0 then
	    local opt = ({src='src', dest='dst'})[attr]
	    table.insert(keys, opt..'ip')
	    maskopts = maskopts..' --hashlimit-'..opt..'mask '..mask
	 end
      end

      table.insert(
	 ofrags,
	 {
	    family=family,
	    opts=keys[1] and
	       '-m hashlimit --hashlimit-upto '..rate..' --hashlimit-burst '..
	       self:intrate()..' --hashlimit-mode '..table.concat(keys, ',')..
	       maskopts..' --hashlimit-name '..(name or self:uniqueid()) or
	       '-m limit --limit '..rate
	 }
      )
   end

   return ofrags
end


M.export = {zone={class=M.Zone}, ipset={class=IPSet, before='%modules'}}

return M
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall.host"])sources["awall.host"]=([===[-- <pack awall.host> --
--[[
Host address resolver for Alpine Wall
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--


local familypatterns = {inet='%d[%.%d/]+',
			inet6='[:%x/]+',
			domain='[%a-][%.%w-]*'}

local function getfamily(addr, context)
   for k, v in pairs(familypatterns) do
      if addr:match('^'..v..'$') then return k end
   end
   context:error('Malformed host specification: '..addr)
end

local dnscache = {}

return function(host, context)
   local family = getfamily(host, context)
   if family == 'domain' then

      if not dnscache[host] then
	 dnscache[host] = {}
	 for rec in io.popen('dig -t ANY '..host):lines() do
	    local name, rtype, addr =
	       rec:match(
		  '^('..familypatterns.domain..')%s+%d+%s+IN%s+(A+)%s+(.+)'
	       )

	    if name and name:sub(1, host:len() + 1) == host..'.' then
	       if rtype == 'A' then family = 'inet'
	       elseif rtype == 'AAAA' then family = 'inet6'
	       else family = nil end

	       if family then
		  assert(getfamily(addr, context) == family)
		  table.insert(dnscache[host], {family, addr})
	       end
	    end
	 end
	 if not dnscache[host][1] then
	    context:error('Invalid host name: '..host)
	 end
	 table.sort(dnscache[host], function(a, b) return a[2] < b[2] end)
      end

      return dnscache[host]
   end

   return {{family, host}}
end
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall.ipset"])sources["awall.ipset"]=([===[-- <pack awall.ipset> --
--[[
Ipset file dumper for Alpine Wall
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--


local sortedkeys = require('awall.util').sortedkeys


local IPSet = require('awall.class')()

function IPSet:init(config) self.config = config or {} end

function IPSet:dumpfile(name, ipsfile)
   ipsfile:write('# ipset '..name..'\n')
   ipsfile:write(table.concat(self.config[name].options, ' '))
   ipsfile:write('\n')
end

function IPSet:create()
   for name, ipset in pairs(self.config) do
      local pid = lpc.run(
	 'ipset', '-!', 'create', name, table.unpack(ipset.options)
      )
      if lpc.wait(pid) ~= 0 then
	 io.stderr:write('ipset creation failed: '..name)
      end
   end
end

function IPSet:print()
   for _, name in sortedkeys(self.config) do
      self:dumpfile(name, io.output())
      io.write('\n')
   end
end

function IPSet:dump(prefix)
   for name, ipset in pairs(self.config) do
      local fname = prefix..name
      local file = io.open(fname)
      if not file then
	 file = io.open(fname, 'w')
	 self:dumpfile(name, file)
      end
      file:close()
   end
end

return IPSet
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall.util"])sources["awall.util"]=([===[-- <pack awall.util> --
--[[
Utility module for Alpine Wall
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--


local M = {}

function M.split(s, sep)
   if s == '' then return {} end
   local res = {}
   while true do
      local si, ei = s:find(sep, 1, true)
      if not si then
	 table.insert(res, s)
	 return res
      end
      table.insert(res, s:sub(1, si - 1))
      s = s:sub(ei + 1, -1)
   end
end

function M.list(var)
   if not var then return {} end
   if type(var) ~= 'table' then return {var} end
   if not next(var) then return {} end
   return var[1] and var or {var}
end

function M.listpairs(var) return ipairs(M.list(var)) end

function M.filter(var, func)
   local res = {}
   for i, v in ipairs(var) do if func(v) then table.insert(res, v) end end
   return res
end

function M.map(var, func)
   local res = {}
   for k, v in pairs(var) do res[k] = func(v) end
   return res
end

function M.maplist(var, func)
   if not var then return var end
   return M.map(M.list(var), func)
end

function M.contains(tbl, value)
   for k, v in M.listpairs(tbl) do if v == value then return true end end
   return false
end

function M.keys(tbl)
   local res = {}
   for k, v in pairs(tbl) do table.insert(res, k) end
   return res
end

function M.values(tbl)
   local res = {}
   for k, v in pairs(tbl) do table.insert(res, v) end
   return res   
end

function M.sortedkeys(tbl)
   local res = M.keys(tbl)
   table.sort(res)
   return ipairs(res)
end

function M.extend(tbl1, tbl2)
   for i, var in M.listpairs(tbl2) do table.insert(tbl1, var) end
end

function M.update(tbl1, tbl2)
   if tbl2 then for k, v in pairs(tbl2) do tbl1[k] = v end end
   return tbl1
end

function M.setdefault(t, k, v)
   if t[k] == nil then t[k] = v end
   return t[k]
end

function M.copy(tbl) return M.update({}, tbl) end

function M.compare(a, b)
   local t = type(a)
   if t ~= type(b) then return false end
   if t ~= 'table' then return a == b end

   local keys = {}
   for k, v in pairs(a) do
      if not M.compare(v, b[k]) then return false end
      table.insert(keys, k)
   end
   for k, v in pairs(b) do
      if not M.contains(keys, k) then return false end
   end
   return true
end

function M.join(a, sep, b)
   local comps = {}
   local function add(s)
      if not s then return end
      s = tostring(s)
      if s > '' then table.insert(comps, s) end
   end
   add(a)
   add(b)
   if comps[1] then return table.concat(comps, sep) end
end


function M.printtabulars(tables)
   local colwidth = {}
   for i, tbl in ipairs(tables) do
      for j, row in ipairs(tbl) do
	 for k, col in ipairs(row) do
	    colwidth[k] = math.max(colwidth[k] or 0, col:len())
	 end
      end
   end
   for i, tbl in ipairs(tables) do
      for j, row in ipairs(tbl) do
	 for k = 1,#row do
	    if k > 1 then io.write('  ') end
	    io.write(row[k])
	    if k < #row then
	       for l = 1,colwidth[k] - row[k]:len() do io.write(' ') end
	    end
	 end
	 io.write('\n')
      end
      io.write('\n')
   end
end

function M.printtabular(tbl) M.printtabulars({tbl}) end

return M
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall.dependency"])sources["awall.dependency"]=([===[-- <pack awall.dependency> --
--[[
Dependency order resolver for Alpine Wall
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--

local util = require('awall.util')
local contains = util.contains

return function(items)
   local visited = {}
   local res = {}

   local function visit(key)
      if contains(res, key) then return end
      if visited[key] then return key end
      visited[key] = true

      local after = util.list(items[key].after)
      for k, v in pairs(items) do
	 if contains(v.before, key) then table.insert(after, k) end
      end
      for i, k in ipairs(after) do
	 if items[k] then
	    local ek = visit(k)
	    if ek ~= nil then return ek end
	 end
      end

      table.insert(res, key)
   end

   for i, k in util.sortedkeys(items) do
      local ek = visit(k)
      if ek ~= nil then return ek end
   end

   return res
end
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall.iptables"])sources["awall.iptables"]=([===[-- <pack awall.iptables> --
--[[
Iptables file dumper for Alpine Wall
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--


local class = require('awall.class')
local raise = require('awall.uerror').raise

local util = require('awall.util')
local sortedkeys = util.sortedkeys


local mkdir = require('posix').mkdir
local lpc = require('lpc')


local M = {}

local families = {inet={cmd='iptables',
			file='rules-save',
			procfile='/proc/net/ip_tables_names'},
		  inet6={cmd='ip6tables',
			 file='rules6-save',
			 procfile='/proc/net/ip6_tables_names'}}

M.builtin = {
   filter={'FORWARD', 'INPUT', 'OUTPUT'},
   mangle={'FORWARD', 'INPUT', 'OUTPUT', 'POSTROUTING', 'PREROUTING'},
   nat={'INPUT', 'OUTPUT', 'POSTROUTING', 'PREROUTING'},
   raw={'OUTPUT', 'PREROUTING'},
   security={'FORWARD', 'INPUT', 'OUTPUT'}
}

local backupdir = '/var/run/awall'


local BaseIPTables = class()

function BaseIPTables:print()
   for _, family in sortedkeys(families) do
      self:dumpfile(family, io.output())
      io.write('\n')
   end
end

function BaseIPTables:dump(dir)
   for family, tbls in pairs(families) do
      local file = io.open(dir..'/'..families[family].file, 'w')
      self:dumpfile(family, file)
      file:close()
   end
end

function BaseIPTables:restore(test)
   local disabled = true

   for family, params in pairs(families) do
      local file = io.open(params.procfile)
      if file then
	 io.close(file)

	 local pid, stdin, stdout = lpc.run(
	    params.cmd..'-restore', table.unpack{test and '-t' or nil}
	 )
	 stdout:close()
	 self:dumpfile(family, stdin)
	 stdin:close()
	 assert(lpc.wait(pid) == 0)

	 disabled = false

      elseif test then
	 io.stderr:write('Warning: '..family..' rules not tested\n')
      end
   end

   if disabled then raise('Firewall not enabled in kernel') end
end

function BaseIPTables:activate()
   M.flush()
   self:restore(false)
end

function BaseIPTables:test() self:restore(true) end


M.IPTables = class(BaseIPTables)

function M.IPTables:init()
   self.config = {}
   setmetatable(self.config,
		{__index=function(t, k)
			    t[k] = {}
			    setmetatable(t[k], getmetatable(t))
			    return t[k]
			 end})
end

function M.IPTables:dumpfile(family, iptfile)
   iptfile:write('# '..families[family].file..' generated by awall\n')
   local tables = self.config[family]
   for i, tbl in sortedkeys(tables) do
      iptfile:write('*'..tbl..'\n')
      local chains = tables[tbl]
      for i, chain in sortedkeys(chains) do
	 local policy = '-'
	 if util.contains(M.builtin[tbl], chain) then
	    policy = tbl == 'filter' and 'DROP' or 'ACCEPT'
	 end
	 iptfile:write(':'..chain..' '..policy..' [0:0]\n')
      end
      for i, chain in sortedkeys(chains) do
	 for i, rule in ipairs(chains[chain]) do
	    iptfile:write('-A '..chain..' '..rule..'\n')
	 end
      end
      iptfile:write('COMMIT\n')
   end
end


local Current = class(BaseIPTables)

function Current:dumpfile(family, iptfile)
   local pid, stdin, stdout = lpc.run(families[family].cmd..'-save')
   stdin:close()
   for line in stdout:lines() do iptfile:write(line..'\n') end
   stdout:close()
   assert(lpc.wait(pid) == 0)
end


local Backup = class(BaseIPTables)

function Backup:dumpfile(family, iptfile)
   for line in io.lines(backupdir..'/'..families[family].file) do
      iptfile:write(line..'\n')
   end
end


function M.backup()
   mkdir(backupdir)
   Current():dump(backupdir)
end

function M.revert() Backup():activate() end

function M.flush()
   local empty = M.IPTables()
   for family, params in pairs(families) do
      local success, lines = pcall(io.lines, params.procfile)
      if success then
	 for tbl in lines do
	    if M.builtin[tbl] then
	       for i, chain in ipairs(M.builtin[tbl]) do
		  empty.config[family][tbl][chain] = {}
	       end
	    else
	       io.stderr:write(
		  'Warning: not flushing unknown table: '..tbl..'\n'
	       )
	    end
	 end
      end
   end
   empty:restore(false)
end

return M
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["awall"])sources["awall"]=([===[-- <pack awall> --
--[[
Alpine Wall main module
Copyright (C) 2012-2014 Kaarle Ritvanen
See LICENSE file for license details
]]--


local M = {}

local class = require('awall.class')
local resolve = require('awall.dependency')
local IPSet = require('awall.ipset')
local IPTables = require('awall.iptables').IPTables
local optfrag = require('awall.optfrag')
M.PolicySet = require('awall.policy')
local util = require('awall.util')


local posix = require('posix')
local chdir = posix.chdir

local endswith = require('stringy').endswith


local events
local procorder
local achains

function M.loadmodules(path)
   events = {}
   achains = {}

   local function readmetadata(mod)
      local export = mod.export or {}
      for name, target in pairs(export) do events[name] = target end

      for name, opts in pairs(mod.achains or {}) do
	 assert(not achains[name])
	 achains[name] = opts
      end

      return util.keys(export)
   end

   readmetadata(require('awall.model'))

   local cdir = posix.getcwd()
   if path then assert(chdir(path)) end

   local modules = {}
   for _, modfile in ipairs(
      posix.dir((path or '/usr/share')..'/awall/modules')
   ) do
      if stringy.endswith(modfile, '.lua') then
	 table.insert(modules, 'awall.modules.'..modfile:sub(1, -5))
      end
   end
   table.sort(modules)

   local imported = {}
   for i, name in ipairs(modules) do
      util.extend(imported, readmetadata(require(name)))
   end

   assert(chdir(cdir))

   events['%modules'] = {before=imported}
   procorder = resolve(events)
end

function M.loadclass(path)
   assert(path:sub(1, 1) ~= '%')
   return events[path] and events[path].class
end


M.Config = class()

function M.Config:init(policyconfig)

   self.objects = policyconfig:expand()
   self.iptables = IPTables()

   local acfrags = {}

   local function insertrules(trules)
      for i, trule in ipairs(trules) do
	 local t = self.iptables.config[trule.family][trule.table][trule.chain]
	 local opts = optfrag.command(trule)

	 if trule.target then
	    local acfrag = {
	       family=trule.family,
	       table=trule.table,
	       chain=trule.target
	    }
	    acfrags[optfrag.location(acfrag)] = acfrag
	 end

	 if trule.position == 'prepend' then
	    table.insert(t, 1, opts)
	 else
	    table.insert(t, opts)
	 end
      end
   end

   for i, path in ipairs(procorder) do
      if path:sub(1, 1) ~= '%' then
	 local objs = self.objects[path]
	 if objs then
	    for k, v in pairs(objs) do
	       objs[k] = events[path].class.morph(
		  v,
		  self,
		  path..' '..k..' ('..policyconfig.source[path][k]..')'
	       )
	    end
	 end
      end
   end

   for i, event in ipairs(procorder) do
      if event:sub(1, 1) == '%' then
	 local r = events[event].rules
	 if r then
	    if type(r) == 'function' then r = r(self.objects) end
	    if r then
	       assert(type(r) == 'table')
	       insertrules(r)
	    end
	 end
      elseif self.objects[event] then
	 for i, rule in ipairs(self.objects[event]) do
	    insertrules(rule:trules())
	 end
      end
   end

   local ofrags = {}
   for k, v in pairs(acfrags) do table.insert(ofrags, v) end
   insertrules(optfrag.combinations(achains, ofrags))

   self.ipset = IPSet(self.objects.ipset)
end

function M.Config:print()
   self.ipset:print()
   io.write('\n')
   self.iptables:print()
end

function M.Config:dump(dir)
   self.ipset:dump(dir and dir..'/ipset-' or '/etc/ipset.d/')
   self.iptables:dump(dir or '/etc/iptables')
end

function M.Config:test()
   self.ipset:create()
   self.iptables:test()
end

function M.Config:activate()
   self:test()
   self.iptables:activate()
end


return M
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
assert(not sources["stringy"])sources["stringy"]=([===[-- <pack stringy> --
local m = {}

--local strong = require "strong"

--m.count = count
--m.find = find
--m.split = split
--m.strip = strip

function m:endswith(suffix)
	return self:sub(-#suffix, -1) == suffix
end
function m:startswith(prefix)
	return self:sub(1, #prefix) == prefix
end

return m
]===]):gsub('\\([%]%[]===)\\([%]%[])','%1%2')
do -- preload auto aliasing...
	local p = require("package").preload
	for k,v in pairs(p) do
		if k:find("%.init$") then
			local short = k:gsub("%.init$", "")
			if not p[short] then
				p[short] = v
			end
		end
	end
end
local add
if not pcall(function() add = require"aioruntime".add end) then
        local loadstring=_G.loadstring or _G.load; local preload = require"package".preload
        add = function(name, rawcode)
		if not preload[name] then
		        preload[name] = function(...) return loadstring(rawcode)(...) end
		else
			print("WARNING: overwrite "..name)
		end
        end
end
for name, rawcode in pairs(sources) do add(name, rawcode, priorities[name]) end
end;

--[[
Alpine Wall
Copyright (C) 2012-2015 Kaarle Ritvanen
See LICENSE file for license details
]]--

local get_opts = require('alt_getopt').get_opts
local lpc
pcall(function() lpc = require('lpc') end)

local posix = require('posix')
local signal = posix.signal

local stringy = require('stringy')

-- Lua 5.1 compatibility
if not table.unpack then table.unpack = unpack end

local function help()
   io.stderr:write([[
Alpine Wall
Copyright (C) 2012-2015 Kaarle Ritvanen
This is free software with ABSOLUTELY NO WARRANTY,
available under the terms of the GNU General Public License, version 2

Usage:

Translate policy files to firewall configuration files:
    awall translate [-o|--output <dir>] [-V|--verify]

    The --verify option makes awall verify the configuration using the
    test mode of iptables-restore before overwriting the old files.

    Specifying the output directory allows testing awall policies
    without overwriting the current iptables and ipset configuration
    files. By default, awall generates the configuration to
    /etc/iptables and /etc/ipset.d, which are read by the init
    scripts.

Run-time activation of new firewall configuration:
    awall activate [-f|--force]

    This command genereates firewall configuration from the policy
    files and enables it. If the user confirms the new configuration
    by hitting RETURN within 10 seconds or the --force option is used,
    the configuration is saved to the files. Otherwise, the old
    configuration is restored.

Flush firewall configuration:
    awall flush

    This command deletes all firewall rules and configures it to drop
    all packets.

Enable/disable optional policies:
    awall {enable|disable} <policy>...

List optional policies:
    awall list [-a|--all]

    The 'enabled' status means that the policy has been enabled by the
    user. The 'disabled' status means that the policy is not in
    use. The 'required' status means that the policy has not been
    enabled by the user but is in use because it is required by
    another policy which is in use.

    Normally, the command lists only optional policies. Specifying
    --all makes it list all policies and more information about them.

Dump variable and zone definitions:
    awall dump [level]

    Verbosity level is an integer in range 0-5 and defaults to 0.

Show difference between modified and saved configurations:
    awall diff [-o|--output <dir>]

    Displays the difference in the input policy files and generated
    output files since the last 'translate' or 'activate' command.

    When the --output option is used, the updated configuration is
    compared to the generated files in the specified directory
    (generated by the equivalent 'translate' command).

]])
   os.exit(1)
end

if not arg[1] then help() end

if not stringy.startswith(arg[1], '-') then
   mode = arg[1]
   table.remove(arg, 1)
end

opts, opind = get_opts(
   arg,
   'afo:V',
   {all='a', force='f', ['output-dir']='o', verify='V'}
)
for switch, value in pairs(opts) do
   if switch == 'a' then all = true
   elseif switch == 'f' then force = true
   elseif switch == 'c' then verbose = true
   elseif switch == 'V' then verify = true
   elseif switch == 'o' then outputdir = value
   else assert(false) end
end

if not mode then
   mode = arg[opind]
   opind = opind + 1
end


util = require('awall.util')
contains = util.contains

if not contains(
   {
      'translate',
      'activate',
      'fallback',
      'flush',
      'enable',
      'disable',
      'list',
      'dump',
      'diff'
   },
   mode
) then help() end

pol_paths = {}
for i, cls in ipairs{'mandatory', 'optional', 'private'} do
   path = os.getenv('AWALL_PATH_'..cls:upper())
   if path then pol_paths[cls] = util.split(path, ':') end
end

if stringy.endswith(arg[0], '/awall-cli') then
   basedir = arg[0]:sub(1, -11)
   util.setdefault(pol_paths, 'mandatory', {'/etc/awall'})
   table.insert(pol_paths.mandatory, basedir..'/json')
end

uerror = require('awall.uerror')
call = uerror.call

if not call(
   function()
      
      local awall = require('awall')
      local printtabular = util.printtabular
      local sortedkeys = util.sortedkeys

      local policyset = awall.PolicySet(pol_paths)

      if mode == 'list' then
	 local imported = policyset:load().policies
	 local data = {}
	 
	 for i, name in sortedkeys(policyset.policies) do
	    local policy = policyset.policies[name]

	    if all or policy.type == 'optional' then
	       if policy.enabled then status = 'enabled'
	       elseif contains(imported, name) then status = 'required'
	       else status = 'disabled' end

	       local polinfo = {name, status, policy:load().description}

	       if all then
		  table.insert(polinfo, 2, policy.type)
		  table.insert(polinfo, 4, policy.path)
	       end

	       table.insert(data, polinfo)
	    end
	 end
	 
	 printtabular(data)
	 os.exit()
      end

      if contains({'disable', 'enable'}, mode) then
	 if opind > #arg then help() end
	 repeat
	    local name = arg[opind]
	    local policy = policyset.policies[name]
	    if not policy then uerror.raise('No such policy: '..name) end
	    policy[mode](policy)
	    opind = opind + 1
	 until opind > #arg
	 os.exit()
      end


      local input = policyset:load()

      if mode == 'dump' then level = 0 + (arg[opind] or 0) end

      local config
      if mode ~= 'dump' or level > 3 then
	 awall.loadmodules(basedir)
	 config = awall.Config(input)
      end


      local function dump(level)
	 local json = require('cjson')
	 local expinput = input:expand()

	 local function capitalize(cls)
	    return cls:sub(1, 1):upper()..cls:sub(2, -1)
	 end

	 for _, cls in sortedkeys(input.data) do
	    if level > 2 or (level == 2 and cls ~= 'service') or contains(
	       {'variable', 'zone'},
	       cls
	    ) then
	       if level == 0 then io.write(capitalize(cls)..'s:\n') end

	       local clsdata = input.data[cls]
	       local items = {}

	       for _, key in sortedkeys(clsdata) do
		  local exp = expinput[cls][key]
		  local expj = json.encode(exp)
		  local src = input.source[cls][key]

		  if level == 0 then table.insert(items, {key, expj, src})

		  else
		     local value = clsdata[key]
		     local data = {
			{capitalize(cls)..' '..key, json.encode(value)},
			{
			   '('..src..')',
			   util.compare(exp, value) and '' or '-> '..expj
			}
		     }

		     if level > 3 then
			local obj = config.objects[cls][key]
			if type(obj) == 'table' and obj.info then
			   util.extend(data, obj:info())
			end
		     end
	       
		     table.insert(items, {key, data})
		  end
	       end
	       table.sort(items, function(a, b) return a[1] < b[1] end)

	       if level == 0 then printtabular(items)
	       else
		  util.printtabulars(
		     util.map(items, function(x) return x[2] end)
		  )
		  io.write('\n')
	       end
	    end
	 end

	 if level > 4 then config:print() end
      end

      local function filedump(file)
	 io.output(file)
	 dump(5)
      end

      local sysdumpfile = '/etc/iptables/awall-save'
      local dumpfile = outputdir and outputdir..'/dump' or sysdumpfile


      local iptables = require('awall.iptables')


      if mode == 'dump' then dump(level)

      elseif mode == 'diff' then
	 if not posix.stat(dumpfile) then
	    io.stderr:write('Please translate or activate first\n')
	    os.exit(1)
	 end

if not lpc then lpc = require "lpc" end

	 local pid, stdin, stdout = lpc.run(
	    'diff', '-w', '--', dumpfile, '/proc/self/fd/0'
	 )

	 filedump(stdin)
	 stdin:close()

	 lpc.wait(pid)
	 io.stdout:write(stdout:read('*all'))
	 stdout:close()
   
      elseif mode == 'translate' then
	 if verify then config:test() end
	 config:dump(outputdir)	 
	 filedump(dumpfile)

      elseif mode == 'activate' then
	if not lpc then lpc = require "lpc" end

	 iptables.backup()

	 local pid, interrupted

	 if not force then
	    signal(
	       posix.SIGCHLD,
	       function()
		  if pid and lpc.wait(pid, 1) then os.exit(2) end
	       end
	    )
	    for i, sig in ipairs({'INT', 'TERM'}) do
	       signal(
		  posix['SIG'..sig],
		  function()
		     interrupted = true
		     io.stdin:close()
		  end
	       )
	    end

	    local stdio, stdout
	    pid, stdio, stdout = lpc.run(arg[0], 'fallback')
	    stdio:close()
	    stdout:close()
	 end

	 local function kill()
	    signal(posix.SIGCHLD, 'SIG_DFL')
	    posix.kill(pid, posix.SIGTERM)
	    lpc.wait(pid)
	 end

	 local function revert()
	    iptables.revert()
	    os.exit(1)
	 end

	 if call(config.activate, config) then

	    if not force then
	       io.stderr:write('New firewall configuration activated\n')
	       io.stderr:write('Press RETURN to commit changes permanently: ')
	       interrupted = not io.read()

	       kill()

	       if interrupted then
		  io.stderr:write(
		     '\nActivation canceled, reverting to the old configuration\n'
		  )
		  revert()
	       end
	    end

	    config:dump()
	    filedump(sysdumpfile)

	 else
	    if not force then kill() end
	    revert()
	 end


      elseif mode == 'fallback' then
   
	 for i, sig in ipairs({'HUP', 'PIPE'}) do
	    signal(posix['SIG'..sig], 'SIG_IGN')
	 end

	 posix.sleep(10)

	 io.stderr:write('\nTimeout, reverting to the old configuration\n')
	 iptables.revert()

      elseif mode == 'flush' then iptables.flush()

      else assert(false) end

   end
) then os.exit(1) end
